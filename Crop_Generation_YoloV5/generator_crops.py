# -*- coding: utf-8 -*-
"""Crop-Data-Segmentation-VRI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mwyY8y6S38ifABhfipRrH_tjp1pjs6f4
    
    
"""

# importing required modules
from zipfile import ZipFile

#FUNCIONES:

import os
import cv2
import numpy as np
from os.path import exists
import shutil 

def generator_crops(labels, images):
  
    # specifying the zip file name
    
    file_txt = labels
    file_img = images
    
    coor_txt = encoder_txt(file_txt)
    imgs_test = enconder_img(file_img)

    
    
    files = os.listdir('.')
    if 'crop_file' in files: shutil.rmtree("crop_file");
    if 'crops_file' in files: shutil.rmtree("crops_file");
    
    os.mkdir("crop_file")
    os.mkdir("crops_file")
    
    
    names = os.listdir(file_img)
    names.sort()
    
    path = 'crop_file'
    path2 = 'crops_file'
    
    
    cont = coor_txt[0][5]
    for i in range(len(imgs_test)):
      name = names[i].split(".")[0]
      while(i == coor_txt[cont][5]):
        crop = extrac_crop(coor_txt[cont], imgs_test[i])
        files_crop(crop,path,name) # Guardamos los crops carpeta por carpeta
        files_crops(crop,path2,name) # guardamos los crops en una sola carpeta llamada "crops_test"
        cont+= 1
        if cont == len(coor_txt):
          break
    print('Ready...!')
'''
n_img = 1
n_txt = 1
xc = coor_txt[n_txt][1]*imgs_test[n_img].shape[1]
yc = coor_txt[n_txt][2]*imgs_test[n_img].shape[0]
w = coor_txt[n_txt][3]*imgs_test[n_img].shape[1]
h = coor_txt[n_txt][4]*imgs_test[n_img].shape[0]

xmin = int(xc - w/2)
xmax = int(xc + w/2)
ymin = int(yc - h/2)
ymax = int(yc + h/2)


ruta  = "/content/images.jpg"
img = cv2.imread(ruta)
#plt.imshow(img[:,:,(2,1,0)])

img[150:155,50:55,:] = (255,255,0)
img[120:125,150:155,:] = (255,0,255)
plt.imshow(img[:,:,(2,1,0)])

#ancho = 100
cv2.imwrite("/content/img_pueba.jpg",img)
n_img = 0
xc = coor_txt[1]*img.shape[1]
yc = coor_txt[2]*img.shape[0]
w = coor_txt[3]*img.shape[1]
h = coor_txt[4]*img.shape[0]


print("{} {} {} {}".format(xc,yc,w,h))

xmin = xc - w/2
xmax = xc + w/2
ymin = yc - h/2
ymax = yc + h/2
print("{} {} {} {}".format(xmin,xmax,ymin,ymax))
'''

"""### Funciones"""



def enconder_img(PATH):
  X = []
  names = os.listdir(PATH) 
  names.sort()
  for i in range(len(names)):
    img_path = "{}/{}".format(PATH,names[i])
    img = cv2.imread(img_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    X.append([img])
  X = np.array(X)
  X = np.squeeze(X)
  return X

def encoder_txt(PATH):
  filas = []
  id = 0
  names = os.listdir(PATH)
  names.sort()
  for i in range(len(names)):
    name = names[i]
    with open("{}/{}".format(PATH,name),"r") as archivo:
        for linea in archivo:
            aux = linea.split()
            for idx in range(len(aux)):
              if aux[idx]=='wound':
                aux[idx] = 0
              else:
                aux[idx] = float(aux[idx])
            aux.append(id)
            filas.append(aux)
    id+=1
  return filas


def files_crop(crop,path,name):
  file_img = "{}/{}".format(path,name)
  if not(exists(file_img)):
    os.mkdir(file_img)
    cv2.imwrite("{}/{}_0.jpg".format(file_img,name), crop)
  else:
    n = len(os.listdir(file_img))
    cv2.imwrite("{}/{}_{}.jpg".format(file_img,name,n), crop)

def extrac_crop(v_coo, img ):
  #Label_ID_1 X_CENTER_NORM Y_CENTER_NORM WIDTH_NORM HEIGHT_NORM
  xc = v_coo[1]*img.shape[1]
  yc = v_coo[2]*img.shape[0]
  w = v_coo[3]*img.shape[1]
  h = v_coo[4]*img.shape[0]
  #coordenadas
  xmin = int(xc - w/2)
  xmax = int(xc + w/2)
  ymin = int(yc - h/2)
  ymax = int(yc + h/2)
  imgOut = img[ymin:ymax,xmin:xmax,(2,1,0)]
  
  return imgOut

def files_crops(crop,path,name):
  file_img = "{}".format(path)
  nam = "{}/{}_0.jpg".format(file_img,name)
  if not(exists(nam)):
    cv2.imwrite(nam, crop)
  else:
    n = len(os.listdir(file_img))
    cv2.imwrite("{}/{}_{}.jpg".format(file_img,name,n), crop)